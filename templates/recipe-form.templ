// templates/recipe-form.templ
package templates

import (
	"recipe-book/models"
	"strconv"
	"fmt"
)

templ RecipeForm(data *models.PageData) {
	@Base(data.Title, data) {
		<div class="form-container">
			<div class="form-header">
				<h1>
					if data.Recipe != nil {
						<i class="fas fa-edit"></i> Edit Recipe
					} else {
						<i class="fas fa-plus"></i> New Recipe
					}
				</h1>
			</div>
			<form id="recipeForm" class="recipe-form" enctype="multipart/form-data">
				@RecipeImageSection(data.Recipe)
				@RecipeBasicInfoSection(data.Recipe)
				@RecipeDetailsSection(data.Recipe)
				@RecipeIngredientsSection(data.Recipe, data.Ingredients)
				@RecipeTagsSection(data.Recipe, data.Tags)
				@RecipeInstructionsSection(data.Recipe)
				<div class="form-actions">
					<a href={ templ.URL(if data.Recipe != nil { "/recipe/" + strconv.Itoa(data.Recipe.ID) } else { "/recipes" }) } class="btn btn-secondary">
						<i class="fas fa-times"></i> Cancel
					</a>
					<button type="submit" class="btn btn-primary">
						<i class="fas fa-save"></i>
						if data.Recipe != nil {
							Update Recipe
						} else {
							Save Recipe
						}
					</button>
				</div>
			</form>
		</div>
		@IngredientModal()
		@TagModal()
		@RecipeFormScript(data.Recipe, data.Ingredients)
	}
}

templ RecipeImageSection(recipe *models.Recipe) {
	<div class="form-section">
		<h3>Recipe Images</h3>
		if recipe != nil && len(recipe.Images) > 0 {
			<div class="existing-images">
				<h4>Current Images</h4>
				<div class="image-gallery">
					for _, img := range recipe.Images {
						<div class="image-item" data-image-id={ strconv.Itoa(img.ID) }>
							<img src={ "/uploads/" + img.Filename } alt={ img.Caption } class="recipe-image-preview"/>
							<div class="image-controls">
								<input type="text" value={ img.Caption } placeholder="Image caption" class="image-caption"/>
								<button type="button" class="btn btn-danger btn-sm delete-image" data-image-id={ strconv.Itoa(img.ID) }>
									<i class="fas fa-trash"></i>
								</button>
							</div>
						</div>
					}
				</div>
			</div>
		}
		<div class="image-upload-section">
			<label for="recipe_images">Add New Images</label>
			<input type="file" id="recipe_images" name="recipe_images" multiple accept="image/*" class="form-control"/>
			<div class="help-text">
				<i class="fas fa-info-circle"></i>
				You can select multiple images. Supported formats: JPG, PNG, GIF. Max size: 5MB per image.
			</div>
			<div id="image-preview-container" class="image-preview-container"></div>
		</div>
	</div>
}

templ RecipeBasicInfoSection(recipe *models.Recipe) {
	<div class="form-section">
		<h3>Basic Information</h3>
		<div class="form-group">
			<label for="title">Recipe Title *</label>
			<input type="text" id="title" name="title" class="form-control" 
				   value={ if recipe != nil { recipe.Title } else { "" } } required/>
		</div>
		<div class="form-group">
			<label for="description">Description</label>
			<textarea id="description" name="description" class="form-control" rows="3" 
					  placeholder="Brief description of your recipe">{ if recipe != nil { recipe.Description } else { "" } }</textarea>
		</div>
	</div>
}

templ RecipeDetailsSection(recipe *models.Recipe) {
	<div class="form-section">
		<h3>Recipe Details</h3>
		<div class="form-grid">
			<div class="form-group">
				<label for="prep_time">Prep Time (minutes)</label>
				<input type="number" id="prep_time" name="prep_time" class="form-control" 
					   value={ if recipe != nil { strconv.Itoa(recipe.PrepTime) } else { "" } } min="0"/>
			</div>
			<div class="form-group">
				<label for="cook_time">Cook Time (minutes)</label>
				<input type="number" id="cook_time" name="cook_time" class="form-control" 
					   value={ if recipe != nil { strconv.Itoa(recipe.CookTime) } else { "" } } min="0"/>
			</div>
			<div class="form-group">
				<label for="servings">Servings</label>
				<input type="number" id="servings" name="servings" class="form-control" 
					   value={ if recipe != nil { strconv.Itoa(recipe.Servings) } else { "" } } min="1"/>
			</div>
			<div class="form-group">
				<label for="serving_unit">Serving Unit</label>
				<select id="serving_unit" name="serving_unit" class="form-control" data-value={ if recipe != nil { recipe.ServingUnit } else { "people" } }>
					@ServingUnitOptions(if recipe != nil { recipe.ServingUnit } else { "people" })
				</select>
			</div>
		</div>
	</div>
}

templ ServingUnitOptions(currentUnit string) {
	for _, unit := range models.ServingUnits {
		<option value={ unit.Value } selected?={ unit.Value == currentUnit }>{ unit.Label }</option>
	}
}

templ RecipeIngredientsSection(recipe *models.Recipe, ingredients []models.Ingredient) {
	<div class="form-section">
		<div class="flex-between mb-3">
			<h3>Ingredients</h3>
			<button type="button" id="add-new-ingredient-btn" class="btn btn-secondary btn-sm">
				<i class="fas fa-plus-circle"></i> Add New Ingredient
			</button>
		</div>
		<div id="ingredients-container">
			if recipe != nil && len(recipe.Ingredients) > 0 {
				for _, ingredient := range recipe.Ingredients {
					@ExistingIngredientRow(ingredient, ingredients)
				}
			}
		</div>
		<button type="button" id="add-ingredient" class="btn btn-secondary">
			<i class="fas fa-plus"></i> Add Ingredient
		</button>
	</div>
}

templ ExistingIngredientRow(ingredient models.RecipeIngredient, allIngredients []models.Ingredient) {
	<div class="ingredient-row">
		<input type="hidden" name="existing_ingredient_id[]" value={ strconv.Itoa(ingredient.IngredientID) }/>
		<input type="hidden" name="existing_quantity[]" value={ fmt.Sprintf("%.2f", ingredient.Quantity) }/>
		<input type="hidden" name="existing_unit[]" value={ ingredient.Unit }/>
		<select name="ingredient_select[]" class="form-control ingredient-select" required>
			<option value="">Select ingredient...</option>
			for _, ing := range allIngredients {
				<option value={ strconv.Itoa(ing.ID) } selected?={ ing.ID == ingredient.IngredientID }>{ ing.Name }</option>
			}
		</select>
		<input type="number" name="quantity_input[]" class="form-control quantity-input" 
			   placeholder="Quantity" step="0.1" min="0" value={ fmt.Sprintf("%.2f", ingredient.Quantity) } required/>
		<select name="unit_select[]" class="form-control unit-select" required>
			<option value="">Unit...</option>
			@UnitOptions(ingredient.Unit)
		</select>
		<button type="button" class="btn btn-danger btn-sm remove-ingredient">
			<i class="fas fa-times"></i>
		</button>
	</div>
}

templ UnitOptions(currentUnit string) {
	<optgroup label="Volume">
		<option value="tsp" selected?={ currentUnit == "tsp" }>Teaspoon</option>
		<option value="tbsp" selected?={ currentUnit == "tbsp" }>Tablespoon</option>
		<option value="cup" selected?={ currentUnit == "cup" }>Cup</option>
		<option value="ml" selected?={ currentUnit == "ml" }>Milliliter</option>
		<option value="l" selected?={ currentUnit == "l" }>Liter</option>
		<option value="fl oz" selected?={ currentUnit == "fl oz" }>Fluid Ounce</option>
	</optgroup>
	<optgroup label="Weight">
		<option value="g" selected?={ currentUnit == "g" }>Gram</option>
		<option value="kg" selected?={ currentUnit == "kg" }>Kilogram</option>
		<option value="oz" selected?={ currentUnit == "oz" }>Ounce</option>
		<option value="lb" selected?={ currentUnit == "lb" }>Pound</option>
	</optgroup>
	<optgroup label="Count">
		<option value="piece" selected?={ currentUnit == "piece" }>Piece</option>
		<option value="clove" selected?={ currentUnit == "clove" }>Clove</option>
		<option value="slice" selected?={ currentUnit == "slice" }>Slice</option>
		<option value="can" selected?={ currentUnit == "can" }>Can</option>
		<option value="package" selected?={ currentUnit == "package" }>Package</option>
	</optgroup>
	<optgroup label="Other">
		<option value="pinch" selected?={ currentUnit == "pinch" }>Pinch</option>
		<option value="dash" selected?={ currentUnit == "dash" }>Dash</option>
		<option value="to taste" selected?={ currentUnit == "to taste" }>To taste</option>
	</optgroup>
}

templ RecipeTagsSection(recipe *models.Recipe, tags []models.Tag) {
	<div class="form-section">
		<h3>Tags</h3>
		<div class="tags-selection">
			<label>Select Categories/Tags (click to toggle)</label>
			<div class="tag-filters">
				for _, tag := range tags {
					@TagFilterForForm(tag, recipe)
				}
			</div>
			<button type="button" id="add-new-tag-btn" class="btn btn-secondary btn-sm" style="margin-top: 1rem;">
				<i class="fas fa-plus-circle"></i> Add New Tag
			</button>
			<div class="help-text">
				<i class="fas fa-info-circle"></i>
				Click on tags to select/deselect them for your recipe.
			</div>
		</div>
	</div>
}

templ TagFilterForForm(tag models.Tag, recipe *models.Recipe) {
	@templ.Raw(`<button type="button" class="tag-filter" data-tag-id="` + strconv.Itoa(tag.ID) + `" data-tag-name="` + tag.Name + `">
		` + tag.Name + `
	</button>
	<input type="checkbox" id="tag_` + strconv.Itoa(tag.ID) + `" name="tags" value="` + strconv.Itoa(tag.ID) + `" class="hidden-checkbox"/>`)
}

templ RecipeInstructionsSection(recipe *models.Recipe) {
	<div class="form-section">
		<h3>Instructions</h3>
		<div class="form-group">
			<label for="instructions">Cooking Instructions *</label>
			<textarea id="instructions" name="instructions" class="form-control instructions-textarea" rows="22" 
					  placeholder="Step-by-step cooking instructions" required>{ if recipe != nil { recipe.Instructions } else { "" } }</textarea>
		</div>
	</div>
}

templ IngredientModal() {
	<div id="ingredient-modal" class="modal hidden">
		<div class="modal-content">
			<div class="modal-header">
				<h3><i class="fas fa-plus-circle"></i> Add New Ingredient</h3>
				<button type="button" class="modal-close" onclick="closeIngredientModal()">
					<i class="fas fa-times"></i>
				</button>
			</div>
			<div class="modal-body">
				<form id="new-ingredient-form">
					<div class="form-group">
						<label for="new-ingredient-name">Ingredient Name *</label>
						<input type="text" id="new-ingredient-name" class="form-control" 
							   placeholder="e.g., Olive Oil, Chicken Breast, etc." required/>
					</div>
					<div class="modal-actions">
						<button type="button" class="btn btn-secondary" onclick="closeIngredientModal()">
							<i class="fas fa-times"></i> Cancel
						</button>
						<button type="submit" class="btn btn-primary">
							<i class="fas fa-save"></i> Add Ingredient
						</button>
					</div>
				</form>
			</div>
		</div>
	</div>
}

templ TagModal() {
	<div id="tag-modal" class="modal hidden">
		<div class="modal-content">
			<div class="modal-header">
				<h3><i class="fas fa-tag"></i> Add New Tag</h3>
				<button type="button" class="modal-close" onclick="closeTagModal()">
					<i class="fas fa-times"></i>
				</button>
			</div>
			<div class="modal-body">
				<form id="new-tag-form">
					<div class="form-group">
						<label for="new-tag-name">Tag Name *</label>
						<input type="text" id="new-tag-name" class="form-control" 
							   placeholder="e.g., Dessert, Quick & Easy, etc." required/>
					</div>
					<div class="form-group">
						<label for="new-tag-color">Tag Color</label>
						<input type="color" id="new-tag-color" class="form-control" value="#ff6b6b"/>
					</div>
					<div class="modal-actions">
						<button type="button" class="btn btn-secondary" onclick="closeTagModal()">
							<i class="fas fa-times"></i> Cancel
						</button>
						<button type="submit" class="btn btn-primary">
							<i class="fas fa-save"></i> Add Tag
						</button>
					</div>
				</form>
			</div>
		</div>
	</div>
}

templ RecipeFormScript(recipe *models.Recipe, ingredients []models.Ingredient) {
	<script>
		let ingredientCounter = 0;
		let allIngredients = [
			for _, ingredient := range ingredients {
				{id: { strconv.Itoa(ingredient.ID) }, name: "{ ingredient.Name }"},
			}
		];
		const isEditMode = { if recipe != nil { "true" } else { "false" } };
		const recipeId = { if recipe != nil { strconv.Itoa(recipe.ID) } else { "null" } };
		
		document.addEventListener('DOMContentLoaded', function() {
			initializeRecipeForm();
			initializeTagButtons();
			setServingUnitValue();
			initializeImageDeletion();
			initializeImageUpload();
			
			// Initialize existing ingredient rows
			document.querySelectorAll('.ingredient-row .remove-ingredient').forEach(btn => {
				btn.addEventListener('click', function() {
					this.closest('.ingredient-row').remove();
				});
			});
		});
		
		function initializeRecipeForm() {
			const form = document.getElementById('recipeForm');
			
			form.addEventListener('submit', async function(e) {
				e.preventDefault();
				
				const submitBtn = this.querySelector('button[type="submit"]');
				const originalText = submitBtn.innerHTML;
				
				submitBtn.disabled = true;
				submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
				
				try {
					const formData = new FormData(this);
					const url = isEditMode ? `/recipe/${recipeId}/edit` : '/api/recipes';
					
					const response = await fetch(url, {
						method: 'POST',
						body: formData
					});
					
					const data = await response.json();
					
					if (data.success) {
						RecipeBook.showNotification(data.message, 'success');
						setTimeout(() => {
							window.location.href = data.redirect;
						}, 1000);
					} else {
						RecipeBook.showNotification(data.error || 'Failed to save recipe', 'error');
					}
				} catch (error) {
					console.error('Recipe save error:', error);
					RecipeBook.showNotification('Failed to save recipe. Please try again.', 'error');
				} finally {
					submitBtn.disabled = false;
					submitBtn.innerHTML = originalText;
				}
			});
			
			document.getElementById('add-ingredient').addEventListener('click', addIngredientRow);
			document.getElementById('add-new-ingredient-btn').addEventListener('click', openIngredientModal);
			document.getElementById('add-new-tag-btn').addEventListener('click', openTagModal);
			document.getElementById('new-ingredient-form').addEventListener('submit', createNewIngredient);
			document.getElementById('new-tag-form').addEventListener('submit', createNewTag);
		}
		
		function initializeTagButtons() {
			document.querySelectorAll('.tag-filter').forEach(button => {
				const tagId = button.dataset.tagId;
				const checkbox = document.getElementById('tag_' + tagId);
				
				// Set initial state for edit mode based on existing checkboxes
				if (checkbox && checkbox.checked) {
					button.classList.add('active');
				}
				
				button.addEventListener('click', function() {
					if (checkbox) {
						checkbox.checked = !checkbox.checked;
						button.classList.toggle('active', checkbox.checked);
					}
				});
			});
		}
		
		function setServingUnitValue() {
			const servingUnitSelect = document.getElementById('serving_unit');
			if (servingUnitSelect) {
				const currentValue = servingUnitSelect.dataset.value || 'people';
				servingUnitSelect.value = currentValue;
			}
		}
		
		function initializeImageDeletion() {
			document.querySelectorAll('.delete-image').forEach(button => {
				button.addEventListener('click', async function() {
					const imageId = this.dataset.imageId;
					const imageItem = this.closest('.image-item');
					
					if (confirm('Are you sure you want to delete this image?')) {
						const originalText = this.innerHTML;
						this.disabled = true;
						this.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
						
						try {
							const response = await fetch(`/api/images/${imageId}`, {
								method: 'DELETE'
							});
							
							if (response.ok) {
								imageItem.style.opacity = '0';
								setTimeout(() => imageItem.remove(), 300);
								RecipeBook.showNotification('Image deleted successfully', 'success');
							} else {
								RecipeBook.showNotification('Failed to delete image', 'error');
							}
						} catch (error) {
							console.error('Image deletion error:', error);
							RecipeBook.showNotification('Failed to delete image', 'error');
						} finally {
							this.disabled = false;
							this.innerHTML = originalText;
						}
					}
				});
			});
		}
		
		function initializeImageUpload() {
			document.getElementById('recipe_images').addEventListener('change', function(e) {
				const files = e.target.files;
				const container = document.getElementById('image-preview-container');
				container.innerHTML = '';
				
				for (let i = 0; i < files.length; i++) {
					const file = files[i];
					if (file.type.startsWith('image/')) {
						const reader = new FileReader();
						reader.onload = function(e) {
							const previewDiv = document.createElement('div');
							previewDiv.className = 'image-preview-item';
							previewDiv.innerHTML = `
								<img src="${e.target.result}" alt="Preview" class="image-preview">
								<input type="text" name="image_captions" placeholder="Caption for this image" class="form-control image-caption-input">
								<button type="button" class="btn btn-danger btn-sm remove-preview" onclick="removeImagePreview(this)">
									<i class="fas fa-times"></i>
								</button>
							`;
							container.appendChild(previewDiv);
						};
						reader.readAsDataURL(file);
					}
				}
			});
		}
		
		function openIngredientModal() {
			const modal = document.getElementById('ingredient-modal');
			modal.classList.remove('hidden');
			modal.style.display = 'flex';
			document.getElementById('new-ingredient-name').focus();
		}
		
		function closeIngredientModal() {
			const modal = document.getElementById('ingredient-modal');
			modal.classList.add('hidden');
			modal.style.display = 'none';
			document.getElementById('new-ingredient-name').value = '';
		}
		
		function openTagModal() {
			const modal = document.getElementById('tag-modal');
			modal.classList.remove('hidden');
			modal.style.display = 'flex';
			document.getElementById('new-tag-name').focus();
		}
		
		function closeTagModal() {
			const modal = document.getElementById('tag-modal');
			modal.classList.add('hidden');
			modal.style.display = 'none';
			document.getElementById('new-tag-name').value = '';
			document.getElementById('new-tag-color').value = '#ff6b6b';
		}
		
		async function createNewIngredient(e) {
			e.preventDefault();
			
			const form = e.target;
			const nameInput = form.querySelector('#new-ingredient-name');
			const name = nameInput.value.trim();
			
			if (!name) {
				RecipeBook.showNotification('Ingredient name is required', 'error');
				return;
			}
			
			if (allIngredients.some(ing => ing.name.toLowerCase() === name.toLowerCase())) {
				RecipeBook.showNotification('This ingredient already exists', 'error');
				return;
			}
			
			const submitBtn = form.querySelector('button[type="submit"]');
			const originalText = submitBtn.innerHTML;
			submitBtn.disabled = true;
			submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
			
			try {
				const response = await fetch('/api/ingredients', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({ name: name })
				});
				
				const data = await response.json();
				
				if (data.success) {
					const newId = Math.max(...allIngredients.map(i => i.id), 0) + 1;
					allIngredients.push({id: newId, name: name});
					updateIngredientSelects();
					closeIngredientModal();
					RecipeBook.showNotification(data.message, 'success');
				} else {
					RecipeBook.showNotification(data.error || 'Failed to create ingredient', 'error');
				}
			} catch (error) {
				console.error('Ingredient creation error:', error);
				RecipeBook.showNotification('Failed to create ingredient', 'error');
			} finally {
				submitBtn.disabled = false;
				submitBtn.innerHTML = originalText;
			}
		}
		
		async function createNewTag(e) {
			e.preventDefault();
			
			const form = e.target;
			const nameInput = form.querySelector('#new-tag-name');
			const colorInput = form.querySelector('#new-tag-color');
			const name = nameInput.value.trim();
			const color = colorInput.value || '#ff6b6b';
			
			if (!name) {
				RecipeBook.showNotification('Tag name is required', 'error');
				return;
			}
			
			const submitBtn = form.querySelector('button[type="submit"]');
			const originalText = submitBtn.innerHTML;
			submitBtn.disabled = true;
			submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
			
			try {
				const response = await fetch('/api/tags', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({ name: name, color: color })
				});
				
				const data = await response.json();
				
				if (data.success) {
					// Add new tag to the form
					const tagFiltersDiv = document.querySelector('.tag-filters');
					const newButton = document.createElement('button');
					newButton.type = 'button';
					newButton.className = 'tag-filter active';
					newButton.dataset.tagId = 'new-' + Date.now();
					newButton.dataset.tagName = name;
					newButton.textContent = name;
					
					const newCheckbox = document.createElement('input');
					newCheckbox.type = 'checkbox';
					newCheckbox.name = 'new_tags[]';
					newCheckbox.value = name;
					newCheckbox.checked = true;
					newCheckbox.className = 'hidden-checkbox';
					newCheckbox.style.display = 'none';
					
					newButton.addEventListener('click', function() {
						newCheckbox.checked = !newCheckbox.checked;
						newButton.classList.toggle('active', newCheckbox.checked);
					});
					
					tagFiltersDiv.appendChild(newButton);
					tagFiltersDiv.appendChild(newCheckbox);
					
					closeTagModal();
					RecipeBook.showNotification(data.message, 'success');
				} else {
					RecipeBook.showNotification(data.error || 'Failed to create tag', 'error');
				}
			} catch (error) {
				console.error('Tag creation error:', error);
				RecipeBook.showNotification('Failed to create tag', 'error');
			} finally {
				submitBtn.disabled = false;
				submitBtn.innerHTML = originalText;
			}
		}
		
		function updateIngredientSelects() {
			const selects = document.querySelectorAll('.ingredient-select');
			selects.forEach(select => {
				const currentValue = select.value;
				select.innerHTML = '<option value="">Select ingredient...</option>';
				allIngredients.forEach(ingredient => {
					const option = document.createElement('option');
					option.value = ingredient.id;
					option.textContent = ingredient.name;
					if (ingredient.id == currentValue) {
						option.selected = true;
					}
					select.appendChild(option);
				});
			});
		}
		
		function addIngredientRow() {
			const container = document.getElementById('ingredients-container');
			const row = document.createElement('div');
			row.className = 'ingredient-row';
			
			let ingredientOptions = '<option value="">Select ingredient...</option>';
			allIngredients.forEach(ingredient => {
				ingredientOptions += `<option value="${ingredient.id}">${ingredient.name}</option>`;
			});
			
			row.innerHTML = `
				<select name="new_ingredient_id[]" class="form-control ingredient-select" required>
					${ingredientOptions}
				</select>
				<input type="number" name="new_quantity[]" class="form-control quantity-input" 
					   placeholder="Quantity" step="0.1" min="0" required>
				<select name="new_unit[]" class="form-control unit-select" required>
					<option value="">Unit...</option>
					<optgroup label="Volume">
						<option value="tsp">Teaspoon</option>
						<option value="tbsp">Tablespoon</option>
						<option value="cup">Cup</option>
						<option value="ml">Milliliter</option>
						<option value="l">Liter</option>
						<option value="fl oz">Fluid Ounce</option>
					</optgroup>
					<optgroup label="Weight">
						<option value="g">Gram</option>
						<option value="kg">Kilogram</option>
						<option value="oz">Ounce</option>
						<option value="lb">Pound</option>
					</optgroup>
					<optgroup label="Count">
						<option value="piece">Piece</option>
						<option value="clove">Clove</option>
						<option value="slice">Slice</option>
						<option value="can">Can</option>
						<option value="package">Package</option>
					</optgroup>
					<optgroup label="Other">
						<option value="pinch">Pinch</option>
						<option value="dash">Dash</option>
						<option value="to taste">To taste</option>
					</optgroup>
				</select>
				<button type="button" class="btn btn-danger btn-sm remove-ingredient">
					<i class="fas fa-times"></i>
				</button>
			`;
			
			container.appendChild(row);
			
			row.querySelector('.remove-ingredient').addEventListener('click', function() {
				row.remove();
			});
		}
		
		function removeImagePreview(button) {
			button.closest('.image-preview-item').remove();
			const fileInput = document.getElementById('recipe_images');
			fileInput.value = '';
		}
		
		// Close modal events
		document.getElementById('ingredient-modal').addEventListener('click', function(e) {
			if (e.target === this) {
				closeIngredientModal();
			}
		});
		
		document.getElementById('tag-modal').addEventListener('click', function(e) {
			if (e.target === this) {
				closeTagModal();
			}
		});
		
		document.addEventListener('keydown', function(e) {
			if (e.key === 'Escape') {
				if (!document.getElementById('ingredient-modal').classList.contains('hidden')) {
					closeIngredientModal();
				}
				if (!document.getElementById('tag-modal').classList.contains('hidden')) {
					closeTagModal();
				}
			}
		});
	</script>
}